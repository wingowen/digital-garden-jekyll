# 数组

## 二分查找

```C
// 有序的无重复元素数组

// 写法一：target 在 [left, right] 之间
Class Sloution{
public:
	int search()(vector<int>& nums, int target) {
		int left = 0;
		int right = nums().size - 1;
		while (left <= right) { // left == right 时 target 区间依然成立
			int middle = (left + right) / 2;
			if (nums[middle] > target){
				right = middle - 1;
			} else if (nums[middle] < target) {
				left = middle + 1;
			} else {
				return middle;
			}
		}
		return -1;
	}
};

// 写法二：target 在 [left, right) 之间
Class Sloution{
public:
	int search()(vector<int>& nums, int target) {
		int left = 0;
		int right = nums().size - 1;
		while(left < right){ // 此时左右相等不成立
			int middle = (left + right) / 2;
			if (nums[middle] < target){
				left = middle + 1;
			} else if (nums[middle] > target){
				right = middle;
			} else {
				return middle;
			}
		}
		return -1;
	}		
};
```

## 移除元素

给你一个数组 `nums` 和一个值 `val`，你需要**原地移除**所有数值等于 `val` 的元素，并返回移除后数组的新长度。

```C
// 示例：给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4

// 暴力解法 时间复杂度为 O(n^2)
Class Solution{
public:
	int removeElement(vector<int>& nums, int val){
		int size = nums.size();
		for (int i = 0; i < size; i++){
			if(nums[i] == val){ // 发现需要移除的元素
				// for (int j = i, j < size, j++){
					// nums[j] = nums[j+1]; 导致越界
				for (int j = i+1, j < size, j++){
					 nums[j-1] = nums[j]; 
				}
				i--; // 前移一位
				size--; // 数组减小一位
			}
		}
		return size;
	}
};

// 双指针法：通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作
// 快指针：寻找新数组的元素，新数组就是不含有目标元素的数组
// 慢指针：指向更新新数组下标的位置


```