---
---
[二哥的 JAVA 进阶之路](https://javabetter.cn/thread/wangzhe-thread.html)

# 多线程

## 基础

### 进程与线程

- **进程**：运行时程序的封装，系统资源调度和分配的基本单位，实现操作系统并发。

- **线程**：进程的子任务，CPU调度和分派的基本单位，实现进程内部并发。

- 线程在进程下进行。

- 进程之间互不影响，主线程结束导致整个进程结束。

- 不同进程数据难共享，同进程下不同线程数据易共享。

- 进程可使用内存地址限定使用量。

区别

- 进程是操作系统分配资源的基本单位，线程是操作系统调度的基本单位。

- 进程拥有独立的内存空间，线程共享所属进程的内存空间。

- 进程的创建和销毁需要资源的分配和回收，开销较大；线程的创建和销毁只需要保存寄存器和栈信息，开销较小。

- 进程间的通信比较复杂，而线程间的通信比较简单。

- 进程间是相互独立的，一个进程崩溃不会影响其他进程；线程间是相互依赖的，一个线程崩溃可能影响整个程序的稳定性。

### 创建线程的三种方式

- **继承 Thread 类**：

- 创建类继承 Thread 并重写 run 方法。

- **实现 Runnable 接口**：

- 创建类实现 Runnable 接口并重写 run 方法。

- **实现 Callable 接口**：

- 实现 Callable 接口，重写 call 方法，可通过 FutureTask 获取返回值。

### run 方法与 start 方法

- **run()**：封装线程执行代码，直接调用相当于调用普通方法。

- **start()**：启动线程，由 JVM 调用此线程的 run() 方法。

### 继承 Thread 与实现 Runnable 接口的比较

- **实现 Runnable 接口优势**：

- 避免 Java 单继承局限性。

- 适合多个相同程序代码处理同一资源，分离线程、代码和数据，符合面向对象设计思想。

### 控制线程的其他方法

- **sleep()**：使当前线程暂停指定毫秒数，需处理异常。

- **join()**：等待线程执行完，后续线程才获得 CPU 执行权，需处理异常。

- **setDaemon()**：将线程标记为守护线程，服务其他线程，主线程结束则 JVM 退出，守护线程停止。

- **yield()**：静态方法，暗示当前线程放弃时间片，允许其他线程执行，但调度器可能忽略。

### 线程生命周期

![](https://ima-notebook-prod.image.myqcloud.com/2/eeT0U4xKE3xYKKq88fofxe/2e0f9042902c44b188eb033a029e8d78.webp?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1746602854;1746631654&q-key-time=1746602854;1746631654&q-header-list=&q-url-param-list=&q-signature=e898391380937b3db30de7b366cbef44112203ca)

## 获取线程执行结果

**Runnable的局限性**：

- **无返回值**：`Runnable`的`run()`方法返回值为`void`，无法获取执行结果。

- **解决方法**：需要通过共享变量或线程通信来获取结果，这种方式较为麻烦。

**Callable的优势**：

- **有返回值**：`Callable`接口定义了一个`call()`方法，可以返回一个泛型类型的结果。

- **使用方法**：通常配合`ExecutorService`使用，通过`submit`方法提交任务，并返回一个`Future`对象来获取结果。

- **示例代码**：展示了如何创建一个包含5个线程的线程池，提交`Callable`任务，并通过`Future`对象获取结果。

**Future接口**：

- **功能**：`Future`接口提供了判断任务是否完成、中断任务和获取执行结果的功能。

- **方法**：

- `cancel()`：取消任务。

- `isCancelled()`：判断任务是否被取消。

- `isDone()`：判断任务是否完成。

- `get()`：获取执行结果，可能会阻塞。

- `get(long timeout, TimeUnit unit)`：在指定时间内获取结果，超时返回`null`。

**FutureTask实现类**：

- **实现接口**：`FutureTask`实现了`RunnableFuture`接口，而`RunnableFuture`继承了`Runnable`和`Future`接口，因此`FutureTask`既可以作为`Runnable`被线程执行，又可以作为`Future`获取结果。

- **构造器**：提供了两个构造器用于创建`FutureTask`对象。

## 线程状态

操作系统的线程**三个基本状态**：

![](https://ima-notebook-prod.image.myqcloud.com/2/eeT0U4xKE3xYKKq88fofxe/d6b5c48a114d47e7b2cb556d6fab42cf.webp?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1746605223%3B1746634023&q-key-time=1746605223%3B1746634023&q-header-list=&q-url-param-list=&q-signature=2ff71085d5a64a5db6dc8392308d693de1416c14)

- **就绪状态(ready)**：线程正在等待使用CPU，经调度程序调用之后进入running状态。

- **执行状态(running)**：线程正在使用CPU。

- **等待状态(waiting)**：线程经过等待事件的调用或者正在等待其他资源（如I/O）。

**Java线程的六种状态**

![](https://ima-notebook-prod.image.myqcloud.com/2/eeT0U4xKE3xYKKq88fofxe/2927a804edfb4307b0f5c2f3be0498db.webp?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1746606433%3B1746635233&q-key-time=1746606433%3B1746635233&q-header-list=&q-url-param-list=&q-signature=c6201eb6bd138f89ede5a59730f35e23d611cab8)

- **NEW**：线程尚未启动，未调用Thread实例的start()方法。

- **RUNNABLE**：线程正在运行中，可能正在等待CPU分配资源。包括操作系统线程的ready和running两个状态。

- **BLOCKED**：线程在等待锁的释放。

- **WAITING**：线程处于等待状态，需要其他线程唤醒。通过Object.wait()、Thread.join()、LockSupport.park()等方法进入。

- **TIMED_WAITING**：超时等待状态，线程等待一个具体的时间，时间到后会被自动唤醒。通过Thread.sleep(long)、Object.wait(long)、Thread.join(long)等方法进入。

- **TERMINATED**：线程已执行完毕。

**线程状态的转换**

- **BLOCKED与RUNNABLE状态的转换**：线程在争夺锁时，未抢到锁的线程会进入BLOCKED状态。

- **WAITING状态与RUNNABLE状态的转换**：通过Object.wait()和Thread.join()方法，线程可以从RUNNABLE状态转为WAITING状态。

- **TIMED_WAITING与RUNNABLE状态转换**：通过Thread.sleep(long)、Object.wait(long)、Thread.join(long)方法，线程可以进入TIMED_WAITING状态，时间到后自动唤醒进入RUNNABLE状态。

**线程中断机制**

- **线程中断**：Java提供线程中断机制来处理需要中断线程的情况。中断操作不能直接终止线程，而是通知线程自行处理。

- **Thread类中的中断方法**：Thread类提供了关于线程中断的几个方法，用于设置和检查线程的中断状态。

- **BLOCKED状态示例**：通过两个线程争夺锁来演示BLOCKED状态的产生。

- **WAITING状态示例**：通过Object.wait()和Thread.join()方法演示WAITING状态的转换。

- **TIMED_WAITING状态示例**：通过Thread.sleep(long)和Thread.join(long)方法演示TIMED_WAITING状态的转换。

## 线程组与优先级

**线程组(ThreadGroup)**

- **定义与作用**：Java使用ThreadGroup类来表示线程组，可以对线程进行批量控制。每个Java线程都必须存在于一个线程组中。

- **数据结构**：ThreadGroup是一个树状结构，每个线程组可以包含多个线程或其他线程组。主要成员变量包括父线程组、名称、最大优先级、是否被销毁、是否守护线程等。

- **构造方法**：ThreadGroup有多个构造方法，可以指定父线程组和名称。私有构造方法会调用checkParentAccess方法来检查权限。

**线程优先级**

- **定义与范围**：线程优先级范围是1~10，Java默认优先级为5。优先级高的线程有更高的概率得到执行，但最终调度由操作系统决定。

- **设置与获取**：使用Thread类的setPriority()方法设置优先级，getPriority()方法获取优先级。

- **验证优先级可靠性**：通过创建多个线程并设置不同优先级，验证优先级的可靠性。结果表明，Java中的优先级只是给操作系统的建议，实际调度顺序由操作系统决定。

- **守护线程**：守护线程默认优先级较低，当所有非守护线程结束时，守护线程会自动结束。可以通过Thread类的setDaemon方法设置为守护线程。

**线程组和线程优先级的关系**

- **优先级一致性**：如果某个线程的优先级大于其所在线程组的最大优先级，则该线程的优先级将失效，取而代之的是线程组的最大优先级。

## 线程的安全问题

### 原子性

- **定义**：原子性指的是一个操作或者一系列操作要么全部执行成功，要么全部不执行，不存在执行一部分的情况。在多线程环境下，如果一个操作不具有原子性，可能会导致数据的不一致。
- **示例**：比如银行账户转账操作，从账户 A 转账到账户 B，需要先从账户 A 扣除相应金额，再给账户 B 增加相应金额。如果这两个操作不具有原子性，在扣除账户 A 金额后，系统崩溃或者线程切换，账户 B 就可能不会收到转账金额，从而导致数据错误。
- **解决方法**：可以使用锁机制（如互斥锁 Mutex、读写锁 ReadWriteLock）或者原子类（如 Java 中的 `AtomicInteger`、`AtomicLong` 等）来保证操作的原子性。锁机制通过对临界区加锁，确保同一时间只有一个线程能访问该区域；原子类则是利用底层硬件的原子操作来实现。

### 可见性

- **定义**：可见性是指当一个线程修改了共享变量的值后，其他线程能够立即看到这个修改。在多线程环境中，由于 CPU 缓存、指令重排序等原因，一个线程对共享变量的修改可能不会立即被其他线程看到，从而导致数据不一致。
- **示例**：假设有一个共享变量 `flag`，线程 A 修改了 `flag` 的值，但线程 B 可能由于缓存的原因，仍然看到的是旧的 `flag` 值，从而做出错误的判断。
- **解决方法**：可以使用 `volatile` 关键字来保证变量的可见性。`volatile` 会禁止指令重排序，并且强制线程每次读取变量时都从主内存中获取最新值，而不是使用缓存中的值。此外，使用锁机制也能保证可见性，因为当一个线程获取锁时，会清空其工作内存中的变量副本，从主内存中重新加载。

### 活跃性

- **定义**：活跃性关注的是线程是否能一直执行下去，是否会因为某些原因导致线程一直阻塞或者无法正常终止。常见的活跃性问题包括死锁、饥饿和活锁。
    - **死锁**：多个线程相互等待对方释放资源，导致所有线程都无法继续执行。例如，线程 A 持有资源 X 并请求资源 Y，而线程 B 持有资源 Y 并请求资源 X，这样两个线程就会陷入死锁状态。
    - **饥饿**：某些线程由于优先级较低或者资源分配策略不合理，长时间得不到执行的机会。比如在一个采用时间片轮转调度算法的系统中，如果高优先级线程一直占用 CPU，低优先级线程就可能永远得不到执行。
    - **活锁**：线程虽然没有被阻塞，但由于不断地尝试执行某个操作而一直失败，导致无法继续前进。例如，两个线程在尝试获取对方持有的锁时，不断地释放自己持有的锁并重新尝试获取对方的锁，从而陷入活锁状态。
- **解决方法**：
    - 对于死锁问题，可以通过破坏死锁产生的四个必要条件（互斥条件、请求与保持条件、不剥夺条件、循环等待条件）来避免，如使用资源有序分配法、银行家算法等。
    - 对于饥饿问题，可以采用公平的调度算法，确保每个线程都有机会执行，或者提高低优先级线程的优先级。
    - 对于活锁问题，可以引入随机等待时间，避免线程一直重复相同的操作。


## JMM

Java 内存模型（Java Memory Model，JMM）定义了 Java 程序中的变量、线程如何和主存以及工作内存进行交互的规则。它主要涉及到多线程环境下的共享变量可见性、指令重排等问题，是理解并发编程中的关键概念。

并发编程的线程之间存在两个问题：
- 线程间如何通信？即：线程之间以何种机制来交换信息
- 线程间如何同步？即：线程以何种机制来控制不同线程间发生的相对顺序

有两种并发模型可以解决这两个问题：
- 消息传递并发模型
- 共享内存并发模型

**Java 使用的是共享内存并发模型**。

![](https://ima-notebook-prod.image.myqcloud.com/2/eeT0U4xKE3xYKKq88fofxe/663fb6fc4015434c9c4afce20b45071e.webp?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1746610027%3B1746638827&q-key-time=1746610027%3B1746638827&q-header-list=&q-url-param-list=&q-signature=a504e76a6b56d56e7fc53b2452c68f204726f7d9)

**线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主存中读取**。
- 主内存：Java堆中对象实例数据部分，对应于物理硬件的内存
- 工作内存：Java栈中的部分区域，优先存储于寄存器和高速缓存

**关键机制：可见性保证**
- **`volatile` 关键字**：
    - 写操作：立即刷新到主存。
    - 读操作：每次从主存重新加载。
- **锁（`synchronized`）**：
    - 释放锁时，线程会将工作内存的修改刷回主存。
    - 获取锁时，线程会清空工作内存，从主存重新加载共享变量。
Java 中的 volatile 关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，synchronized 关键字不仅保证可见性，同时也保证了原子性（互斥性）。

JMM 定义了多线程之间如何互相交互的规则，主要目的是为了解决由于编译器优化、处理器优化和缓存系统等导致的可见性、原子性和有序性。
- 可见性：当一个线程修改了共享变量的值，这个新值对于其他线程来说可以立即知道。
- 原子性：一个或多个操作在整个过程中，不会被其他的线程或者操作所打断，这些操作是一个整体，要么都执行，要么都不执行。
- 有序性：程序执行的顺序按照代码的先后顺序执行的。

指令重排一般分为以下三种：
- **编译器优化重排**，编译器在**不改变单线程程序语义**的前提下，重新安排语句的执行顺序。
- **指令并行重排**，现代处理器采用了指令级并行技术来将多条指令重叠执行。如果**不存在数据依赖性**(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。
- **内存系统重排**，由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。
**指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致**。所以在多线程下，指令重排序可能会导致一些问题。

总结
- Java 内存模型（JMM）定义了 Java 程序中的变量、线程如何和主存以及工作内存进行交互的规则。它主要涉及到多线程环境下的共享变量可见性、指令重排等问题，是理解并发编程中的关键概念。
- Java 内存模型（JMM）主要针对的是多线程环境下，如何在主内存与工作内存之间安全地执行操作。
- Java 运行时内存区域描述的是在 JVM 运行时，如何将内存划分为不同的区域，并且每个区域的功能和工作机制。主要包括方法区、堆、栈、本地方法栈、程序计数器。
- 指令重排是为了提高 CPU 性能，但是可能会导致一些问题，比如多线程环境下的内存可见性问题。
- happens-before 规则是 JMM 提供的强大的内存可见性保证，只要遵循 happens-before 规则，那么我们写的程序就能保证在 JMM 中具有强的内存可见性。

## volatile

**`volatile` 关键字的特性**
- **保证可见性**：当一个线程写入一个 `volatile` 变量时，JMM 会将该线程在本地内存中的变量强制刷新到主内存中，使得其他线程中的 `volatile` 变量缓存无效。        
- **禁止指令重排**：`volatile` 关键字会插入内存屏障，确保写操作之前的所有变量的写入操作都提交到主内存，并且在读操作时，所有读操作都从主内存中读取。

**指令重排的规则**
- **数据依赖关系**：重排序不会对存在数据依赖关系的操作进行重排序。例如，`a=1;b=a;` 不会被重排序。
- **单线程下的执行结果**：重排序是为了优化性能，但单线程下程序的执行结果不能被改变。例如，`a=1;b=2;c=a+b;` 中的 `c=a+b` 不会被重排序。

**总结**
- `volatile` 保证线程可见性和一定的有序性，但不保证原子性。
- 在 JVM 底层通过“内存屏障”实现，确保指令重排序时不会把后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面。
- 适用于需要保证可见性和有序性但不需要原子性的场景，不适用于需要原子性的场景（如自增操作）。

## synchronized

悲观锁。

**synchronized 关键字的作用**    
- **保证线程互斥**：在同一个时刻，只有一个线程可以执行某个方法或者某个代码块（主要是对方法或者代码块中存在共享数据的操作）。
- **保证可见性**：一个线程的变化（主要是共享数据的变化）被其他线程所看到，完全可以替代 `volatile` 功能。

**synchronized 的三种应用方式**    
- **同步方法**：为当前对象（`this`）加锁，进入同步代码前要获得当前对象的锁。    
- **同步静态方法**：为当前类加锁（锁的是 Class 对象），进入同步代码前要获得当前类的锁。
- **同步代码块**：指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。

```java
// 关键字在实例方法上，锁为当前实例
public synchronized void instanceLock() {
    // code
}

// 关键字在静态方法上，锁为当前Class对象
public static synchronized void classLock() {
    // code
}

// 关键字在代码块上，锁为括号里面的对象
public void blockLock() {
    Object o = new Object();
    synchronized (o) {
        // code
    }
}
```

**可重入锁**：一个线程调用 `synchronized` 方法的同时，在其方法体内部调用该对象另一个 `synchronized` 方法是允许的

**指令重排情况分析**、**happens-before 关系**：`synchronized` 会防止临界区内的代码与外部代码发生重排序，保证执行顺序和内存可见性。例如，`writer()` 方法中 `a++` 的执行和 `reader()` 方法中 `a` 的读取之间存在 happens-before 关系。

**性能考虑**
- **合理使用**：不应将整个方法或者更大范围的代码块做同步，而应尽可能地缩小同步范围。
- **优化**：在 JVM 的后续版本中，对 `synchronized` 进行了大量优化，如偏向锁、轻量级锁和适应性自旋等，性能在许多情况下都很好。

**Java多线程的锁基于对象，每个对象都能作为锁**
- 类锁本质上是对象锁。
- Class对象是特殊Java对象，代表程序中的类和接口，每种类型（类、接口、数组、基础类型）在JVM中都有唯一对应的Class对象。
- Class对象在JVM加载类时由JVM自动创建。

## 锁的状态

|锁|优点|缺点|适用场景|
|---|---|---|---|
|偏向锁|加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。|如果线程间存在锁竞争，会带来额外的锁撤销的消耗。|适用于只有一个线程访问同步块场景。|
|轻量级锁|竞争的线程不会阻塞，提高了程序的响应速度。|如果始终得不到锁竞争的线程使用自旋会消耗 CPU。|追求响应时间。同步块执行速度非常快。|
|重量级锁|线程竞争不使用自旋，不会消耗 CPU。|线程阻塞，响应时间缓慢。|追求吞吐量。同步块执行时间较长。|

>在 Java 中，监视器（monitor）是一种同步工具，用于保护共享数据，避免多线程并发访问导致数据不一致。在 Java 中，每个对象都有一个内置的监视器。
>监视器包括两个重要部分，一个是锁，一个是等待/通知机制，后者是通过 Object 类中的`wait()`, `notify()`, `notifyAll()`等方法实现的

**偏向锁**

偏向锁使用了一种**等到竞争出现才释放锁的机制**，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。

偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：

1. 在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。
2. 遍历线程栈，如果存在锁记录的话，需要修复锁记录和 Mark Word，使其变成无锁状态。
3. 唤醒被停止的线程，将当前锁升级成轻量级锁。

所以，如果应用程序里所有的锁通常处于竞争状态，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭 `-XX:UseBiasedLocking=false`。

**轻量级锁**

多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM 采用轻量级锁来避免线程的阻塞与唤醒。

JVM 会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，我们称为 Displaced Mark Word。如果一个线程获得锁的时候发现是轻量级锁，会把锁的 Mark Word 复制到自己的 Displaced Mark Word 里面。

然后线程尝试用 CAS 将锁的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示 Mark Word 已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。

自旋也不是一直进行下去的，如果自旋到一定程度（和 JVM、操作系统相关），依然没有获取到锁，称为自旋失败，那么这个线程会阻塞。同时这个锁就会**升级成重量级锁**。

### 锁的升级流程

每一个线程在准备获取共享资源时： 第一步，检查 MarkWord 里面是不是放的自己的 ThreadId ,如果是，表示当前线程是处于 “偏向锁” 。

第二步，如果 MarkWord 不是自己的 ThreadId，锁升级，这时候，用 CAS 来执行切换，新的线程根据 MarkWord 里面现有的 ThreadId，通知之前线程暂停，之前线程将 Markword 的内容置为空。

第三步，两个线程都把锁对象的 HashCode 复制到自己新建的用于存储锁的记录空间，接着开始通过 CAS 操作， 把锁对象的 MarKword 的内容修改为自己新建的记录空间的地址的方式竞争 MarkWord。

第四步，第三步中成功执行 CAS 的获得资源，失败的则进入自旋 。

第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败 。

第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。

## CAS

CAS（Compare-and-Swap）是一种被广泛应用在并发控制中的算法，它是一种乐观锁的实现方式。CAS 全称为“比较并交换”，是一种无锁的原子操作。

CAS 的全称是：比较并交换（Compare And Swap）。在 CAS 中，有这样三个值：

- V：要更新的变量(var)
- E：预期值(expected)
- N：新值(new)

比较并交换的过程如下：

判断 V 是否等于 E，如果等于，将 V 的值设置为 N；如果不等，说明已经有其它线程更新了 V，于是当前线程放弃更新，什么都不做。

这里的**预期值 E 本质上指的是“旧值”**。

CAS 虽好，但也有一些问题，比如说 ABA 问题、循环时间长开销大、只能保证一个共享变量的原子操作等。在开发中，我们要根据实际情况来选择使用 CAS 还是使用锁。




# JVM

![[assets/images/JAVA-1.png]]

![[assets/images/JAVA-2.png]]

**重载和重写**

- 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
- 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法

**字符常量和字符串常量**

- 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。
- 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。

**反射（Reflection）**

Java 语言的核心特性之一，允许程序在**运行时**动态地**获取类的信息**（如类名、方法、字段、构造器等），并直接**操作类或对象**的内部属性（包括私有成员）。简单来说，反射让 Java 程序具备了“自省”和“动态行为”的能力。

**成员变量**在运行时可借助反射等方法手动赋值，而**局部变量不行**。

**堆栈、方法区**

| **变量类型**   | **存储位置**    | **生命周期管理** | **示例**                  |
| ---------- | ----------- | ---------- | ----------------------- |
| 局部变量（基本类型） | 虚拟机栈（局部变量表） | 方法结束自动释放   | `int x = 5;`            |
| 非静态成员变量    | 堆（对象实例内部）   | 由GC回收      | `class A { int n; }`    |
| 静态变量（基本类型） | 方法区（元空间）    | 类卸载时释放     | `static int count = 0;` |

**抽象类和接口**

抽象类是对一种事物的抽象，即对类抽象，继承抽象类的子类和抽象类本身是一种 `is-a` 的关系。而接口是对行为的抽象。

抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。

举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类 Airplane，将鸟设计为一个类 Bird，但是不能将飞行这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口 Fly，包含方法 fly()，然后 Airplane 和 Bird 分别根据自己的需要实现 Fly 这个接口。


