# Java 场景题目

**深分页为什么慢？**

```sql
select * from p where age>1 -- age 是二级索引
limit 50000,100
-- 会拿 0 到 50100 条数据
-- 查询非索引字段，做回表查询
select id,age,name from tb_user join
(select id from users where id > 50000 and age > 1 limit 100) tmp
on p.id = tmp.id
-- 若 id 代表条数可以用以上优化方式
-- 分库分表
-- ES
```

- Server：语法解析 > 预处理 > 优化 SQL
- 引擎 > 

回表查询会进一步降低性能，这时候要进行索引覆盖。

联合索引：遵循最左前缀原则。

---

**秒杀系统如何设计？**

痛点：流量激增、库存少

CDN（Content Delivery Network，内容分发网络）是一种分布式网络技术，用于将内容缓存到全球范围内的多个服务器上，以提高用户访问速度和可靠性。CDN 服务器是 CDN 网络中的核心组成部分，它们的主要作用是存储和分发静态和动态内容，例如网页、图片、视频、文件等。

Redis 支持使用 Lua 脚本执行原子操作，这使得 Redis 脚本非常适合处理复杂的事务、原子更新和高性能需求的场景。

---

**优化商品类型数据过大问题**

引入 Redis > 引入定时器 > 引入二级缓存 > 开启 Nginx Gzip > 优化 Redis 的存储数据

---

**OOM 的原因**
- 一次性申请太多对象 > 分多次
- 资源申请使用完后未释放 > 池
- 本身资源过小








# 计算机网络

## TCP

三次握手：TCP 建立连接的过程就是同步序列号的过程，SYN (Synchronize Sequence Numbers)就是同步序列号。因此，三次握手的目的就是使客户端(Client)和服务端(Service)获取到对方的序列号。

四次挥手：tcp 是**全双工**协议，即客户端和服务端都可以主动发送消息，因此需要两端分别在传输完成后发送断开连接的指令，需要分别发送 `FIN=1` 指令断开，通过 `ACK` 判断是否发送成功。

![](assets/images/面试题目整理-1.png)

TCP 通过以下几个特性保证数据传输的可靠性
- 序列号和确认应答
- 超时重传
- 流量控制
- 拥塞控制
- 校验和


# Redis

Redis 主从架构，提高数据的冗余性和读取性。
- Master 主节点，接收客户端读写操作，并将写操作数据同步到从节点。
- Slave 从节点：从主节点复制数据，提供读操作，减轻主节点的读取压力。当主节点出现故障时可升级为 Master 保证系统的可用性。
数据同步。
- 全量同步：主节点执行 BGSAVE 操作，生成一个 RDB 文件发送给从节点。同步过程中缓存新的写操作，全量完成后再将缓存的命令发送给从节点，以保证数据的一致性。
- 部份同步 PSYNC：复制积压缓冲区 Replication Backlog。从节点通过 PSYNC 命令加上次同步的偏移量向主节点请求部份同步。若断联时间过长，无法部份同步则退化为全量同步。
配置：在从节点的配置文件见指定主节点的 IP 地址和端口号。

**RDB** 文件中包含了 Redis 数据库某一时刻的所有键值对，以及这些键值对的类型、大小、过期时间等信息。

**AOF**（Append Only File）持久化是一种通过记录所有写操作命令来实现数据持久化的方式。

**Sentinel** 哨兵服务
- 监控 Monitoring，Sentinel 可用持续不断地检查主从实例是否如期运行。
- 通知 Notification，当某个被监控的 Redis 实例出问题的时候，可以通过 API 接口向系统管理员和其他应用服务发通知。
- 自动故障转移 Automatic failover，当主出现故障时，Sentinel 会自动启动故障转移流程，把其中一个从库提升为主库，然后其他从库重新认新主。集群也会返回新的地址给客户端。
- 配置提供 Configuration provider，Sentinel 可以作为服务注册中心，让客户端直接连接请求 Sentinel 去获取主库的地址。如果出现自动故障转移，Sentinel 也会提供新的主库地址。

SpringBoot 下基于 Redis 主从模式的日志收集系统实现方案
- 生产者应用 → Redis 主节点 (写入) → Redis 从节点 (复制) → 消费者服务 (读取处理)
- 优势
	- **高性能写入**：Redis 内存操作支持每秒数万级日志写入。
	- **读写分离**：主节点专注写入，从节点分担读取压力，提升整体吞吐量。
	- **数据冗余**：从节点提供数据备份，避免单点故障导致日志丢失。
	- **实时性**：相比磁盘存储，Redis 提供低延迟的日志收集能力。
- 不足与解决方案
	- **数据丢失风险**：启用 `AOF` 持久化 + 定期 RDB 快照，或结合 Kafka 做缓冲。
		- 双写保障：客户端 → Redis（实时读写/缓存） → Kafka（异步持久化） → 大数据系统（分析处理）
	- **主从同步延迟**：对实时性要求高的场景，消费者直接读主节点（牺牲部分负载均衡）。
	- **内存限制**：设置 `maxmemory` 策略（如 LRU 淘汰），或定期清理已消费日志。
	- **单点故障**：引入 Redis Sentinel 实现自动故障转移。
- 扩展建议
	- **分级存储**：重要日志（如 ERROR 级别）同步写入数据库，普通日志异步处理。
	- **监控告警**：通过 Prometheus + Grafana 监控 Redis 内存、QPS 及主从同步状态。
	- **消费者集群化**：部署多个消费者实例，通过 Redis 的 `BLPOP` 或消费者组实现并行处理。

### 高难度

**1. Redis 集群脑裂导致数据丢失怎么办？**
- **脑裂现象**：在 Redis 主从架构中，当主节点网络出现问题与从节点失联，但主节点与客户端网络正常时，主节点仍可接收写操作，而哨兵会误判主节点故障，从从节点中选举出新的主节点，此时出现两个主节点，即脑裂现象。当网络恢复后，原主节点会被降级为从节点，其数据会被清空并同步新主节点的数据，导致之前写入原主节点的数据丢失。
- **解决方案**：在 Redis 的配置文件中设置 `min-slaves-to-write x` 和 `min-slaves-max-lag x` 参数。其中，`min-slaves-to-write x` 表示主节点必须至少有 x 个从节点连接，若少于 x 个，则主节点禁止写操作；`min-slaves-max-lag x` 表示主从数据复制和同步的延迟不能超过 x 秒，若超过，则主节点禁止写操作。通过合理设置这两个参数，可防止主节点在与从节点失联时继续接收写操作，从而避免脑裂导致的数据丢失。

**2. Redis 的内存淘汰策略有哪些？**
- Redis 提供 8 种内存淘汰策略，主要分为两类：不进行数据淘汰的策略和进行数据淘汰的策略。
- **不进行数据淘汰的策略**：`noeviction`，当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。
- **进行数据淘汰的策略**：
  - `volatile-lru`：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。
  - `volatile-ttl`：从已设置过期时间的数据集中挑选将要过期的数据淘汰。
  - `volatile-random`：从已设置过期时间的数据集中任意选择数据淘汰。
  - `allkeys-lru`：从所有数据集中挑选最近最少使用的数据淘汰。
  - `allkeys-random`：从所有数据集中任意选择数据淘汰。
  - `volatile-lfu`：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰。
  - `allkeys-lfu`：从所有数据集中挑选最不经常使用的数据淘汰。

**3. Redis 的事务是如何实现的？**
- Redis 使用 `MULTI`、`EXEC`、`DISCARD` 和 `WATCH` 等命令来支持事务。
- **事务的开启**：客户端发送 `MULTI` 命令，Redis 会将后续的命令记录到队列中，但不会立即执行。
- **事务的执行**：当客户端发送 `EXEC` 命令时，Redis 会一次性执行队列中的所有命令，并将执行结果返回给客户端。
- **事务的回滚**：如果在执行事务之前，客户端发送了 `DISCARD` 命令，则会清空队列中的命令，事务不会执行。
- **事务的监控**：客户端可以使用 `WATCH` 命令监控某些 key，如果在事务执行之前这些 key 被其他客户端修改，则事务会失败。
- Redis 的事务是原子性的，要么全部执行，要么全部不执行。

### 中难度

**4. Redis 的持久化机制有哪些？各自的优缺点是什么？**
- Redis 提供两种持久化机制：RDB 和 AOF。
- **RDB 持久化**：
  - 优点：只生成一个文件，方便持久化和备份；性能最大化，通过 fork 子进程完成写操作，不影响主进程性能；数据恢复速度快。
  - 缺点：数据安全性低，若在两次快照之间 Redis 发生故障，会丢失部分数据。
- **AOF 持久化**：
  - 优点：数据安全性高，可配置 `appendfsync` 属性，如 `always` 每次操作都写入文件，`everysec` 每秒同步一次，可减少数据丢失风险；即使中途服务器宕机，可通过 `redis-check-aof` 工具解决数据一致性问题。
  - 缺点：AOF 文件比 RDB 文件大，恢复速度慢；数据集大时，启动效率低。

**5. Redis 的主从复制是如何实现的？**
- Redis 的主从复制通过异步方式将主节点的数据复制到从节点，实现数据的备份和高可用性。
- **复制过程**：从节点启动时，会向主节点发送 `SYNC` 命令，请求同步数据。主节点接收到命令后，会执行 `BGSAVE` 命令生成 RDB 文件，并将后续的写操作记录到内存缓冲区。当 RDB 文件生成完成后，主节点会将 RDB 文件发送给从节点，从节点接收并加载 RDB 文件到内存。加载完成后，主节点会将内存缓冲区中的写操作发送给从节点，从节点执行这些操作，完成数据同步。
- **复制优化**：Redis 4.0 引入了部分重同步机制，当主从节点之间发生网络闪断时，从节点可以请求主节点发送丢失的数据，而无需重新同步整个数据集。

**6. Redis 的过期键删除策略有哪些？**
- Redis 采用三种策略删除过期键：惰性删除、定期删除和定时删除。
- **惰性删除**：当访问某个键时，检查该键是否过期，若过期则删除。优点是不主动删除过期键，节省系统资源，对 CPU 最友好；缺点是过期键占用的内存不会及时释放，可能导致内存浪费。
- **定期删除**：每隔一段时间，程序随机检查数据库中的部分键，删除其中的过期键。优点是能定期清理过期键，减少内存占用；缺点是难以确定删除操作的频率和数量，若频率过低，过期键占用的内存不能及时释放；若频率过高，会增加 CPU 负担。
- **定时删除**：在设置键的过期时间时，创建一个定时器，当键到期时立即删除。

### 低难度

**7. Redis 是什么？它有哪些主要特点？**
- Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存、消息队列、分布式锁等场景。
- Redis 提供了多种数据类型来支持不同的业务场景，比如 String、Hash、List、Set、Zset、Bitmaps、HyperLogLog、GEO、Stream，并且对数据类型的操作都是原子性的，因为执行命令由单线程负责，不存在并发竞争的问题。
- Redis 还支持事务、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片集群模式）、发布/订阅模式、内存淘汰机制、过期删除机制等。

**8. Redis 的数据类型有哪些？**
- Redis 提供了丰富的数据类型，常见的有五种数据类型：String（字符串）、Hash（哈希）、List（列表）、Set（集合）、Zset（有序集合）。
- 随着 Redis 版本的更新，后面又支持了四种数据类型：BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。

**9. Redis 相比 Memcached 有哪些优势？**
- Redis 支持的数据类型更丰富（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型。
- Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了。
- Redis 原生支持集群模式，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。
- Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。