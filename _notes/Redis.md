# 缓存穿透（Cache Penetration）

请求的**数据在数据库和缓存中都不存在**（如恶意请求不存在的 ID）。导致大量无效请求绕过缓存直接访问数据库，导致数据库压力骤增。

**解决方案**

布隆过滤器（Bloom Filter）
- 在缓存层前加布隆过滤器，快速判断数据是否存在。
- 若布隆过滤器标记数据不存在，直接拦截请求，避免查询数据库。

缓存空对象（Cache Null）
- 对数据库查询结果为空的请求，缓存一个短期的空值（如 `key: null, TTL: 5min`），防止重复穿透。

# 缓存击穿（Cache Breakdown）

**某个热点数据过期**时，大量并发请求同时涌入数据库。导致针对单个热点数据的瞬时高并发压力，可能导致数据库崩溃。

**解决方案**

互斥锁（Mutex Lock）
- 当缓存失效时，通过分布式锁（如 Redis 的 `SETNX`）控制只有一个线程重建缓存，其他线程等待并轮询缓存。

逻辑过期（Logical Expiration）
- 缓存不设置物理 TTL，而是在数据中存储逻辑过期时间。
- 后台异步更新数据，避免请求线程阻塞。

永不过期热点数据
- 对极高频的热点数据（如首页 Banner），直接设置为永不过期，通过异步线程定期更新。

# 缓存雪崩（Cache Avalanche）

- **触发条件**：**大量缓存数据同时过期**，或**缓存服务宕机**。
    
- **影响**：瞬时大规模缓存失效，请求直接冲击数据库，导致系统级联故障。
    

#### **解决方案**

- **随机化过期时间**
    
    - 对缓存数据的 TTL 添加随机值（如 `基础时间 + 随机分钟`），避免同时失效。
        
- **多级缓存（Multi-level Cache）**
    
    - 本地缓存（如 Caffeine） + 分布式缓存（如 Redis），减少对单一缓存层的依赖。
        
- **熔断降级与限流**
    
    - 通过熔断机制（如 Hystrix）在数据库压力过大时拒绝请求，或限流（如 Sentinel）控制并发量。
        
- **集群高可用**
    
    - 使用 Redis 集群或哨兵模式，避免单点故障导致全盘崩溃。
        

---

### **对比总结表**

|**问题类型**|**触发原因**|**影响范围**|**核心解决方案**|
|---|---|---|---|
|**缓存穿透**|查询不存在的数据|单个无效请求|布隆过滤器、缓存空对象|
|**缓存击穿**|热点数据过期|单个热点数据|互斥锁、逻辑过期、永不过期热点|
|**缓存雪崩**|大量缓存同时失效或服务宕机|全局性缓存层崩溃|随机化 TTL、多级缓存、熔断限流|

---

### **实际场景示例**

1. **缓存穿透**
    
    - 恶意攻击者构造大量非法 ID（如负数值、超大数值），绕过正常业务逻辑。
        
    - **防御**：对参数合法性校验（如 ID 范围检查） + 布隆过滤器拦截。
        
2. **缓存击穿**
    
    - 电商大促时，某个热门商品详情页缓存失效，瞬间涌入百万级请求。
        
    - **防御**：使用 Redis 分布式锁，确保只有一个线程回源数据库重建缓存。
        
3. **缓存雪崩**
    
    - Redis 集群宕机，或所有缓存 Key 设置为相同 TTL（如凌晨 0 点统一过期）。
        
    - **防御**：缓存 TTL 基础值设为 `24h + 随机 0~2h`，避免集中失效。
        

---

### **设计原则**

1. **缓存空值**：减少无效请求穿透到数据库。
    
2. **分散失效时间**：避免同时失效引发的连锁反应。
    
3. **冗余与降级**：通过多级缓存和熔断机制保障系统可用性。
    
4. **热点隔离**：对高频数据单独处理（如本地缓存 + 永不过期）。
    

理解这三个问题的差异，能帮助在架构设计中针对性地制定策略，平衡缓存性能与数据一致性。