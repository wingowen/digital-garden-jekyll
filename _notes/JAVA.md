---
---
[二哥的 JAVA 进阶之路](https://javabetter.cn/thread/wangzhe-thread.html#_4-yield)

# 多线程

## 基础

### 进程与线程

- **进程**：运行时程序的封装，系统资源调度和分配的基本单位，实现操作系统并发。

- **线程**：进程的子任务，CPU调度和分派的基本单位，实现进程内部并发。

- 线程在进程下进行。

- 进程之间互不影响，主线程结束导致整个进程结束。

- 不同进程数据难共享，同进程下不同线程数据易共享。

- 进程可使用内存地址限定使用量。

区别

- 进程是操作系统分配资源的基本单位，线程是操作系统调度的基本单位。

- 进程拥有独立的内存空间，线程共享所属进程的内存空间。

- 进程的创建和销毁需要资源的分配和回收，开销较大；线程的创建和销毁只需要保存寄存器和栈信息，开销较小。

- 进程间的通信比较复杂，而线程间的通信比较简单。

- 进程间是相互独立的，一个进程崩溃不会影响其他进程；线程间是相互依赖的，一个线程崩溃可能影响整个程序的稳定性。

### 创建线程的三种方式

- **继承 Thread 类**：

- 创建类继承 Thread 并重写 run 方法。

- **实现 Runnable 接口**：

- 创建类实现 Runnable 接口并重写 run 方法。

- **实现 Callable 接口**：

- 实现 Callable 接口，重写 call 方法，可通过 FutureTask 获取返回值。

### run 方法与 start 方法

- **run()**：封装线程执行代码，直接调用相当于调用普通方法。

- **start()**：启动线程，由 JVM 调用此线程的 run() 方法。

### 继承 Thread 与实现 Runnable 接口的比较

- **实现 Runnable 接口优势**：

- 避免 Java 单继承局限性。

- 适合多个相同程序代码处理同一资源，分离线程、代码和数据，符合面向对象设计思想。

### 控制线程的其他方法

- **sleep()**：使当前线程暂停指定毫秒数，需处理异常。

- **join()**：等待线程执行完，后续线程才获得 CPU 执行权，需处理异常。

- **setDaemon()**：将线程标记为守护线程，服务其他线程，主线程结束则 JVM 退出，守护线程停止。

- **yield()**：静态方法，暗示当前线程放弃时间片，允许其他线程执行，但调度器可能忽略。

### 线程生命周期

![](https://ima-notebook-prod.image.myqcloud.com/2/eeT0U4xKE3xYKKq88fofxe/2e0f9042902c44b188eb033a029e8d78.webp?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1746602854;1746631654&q-key-time=1746602854;1746631654&q-header-list=&q-url-param-list=&q-signature=e898391380937b3db30de7b366cbef44112203ca)

## 获取线程执行结果

**Runnable的局限性**：

- **无返回值**：`Runnable`的`run()`方法返回值为`void`，无法获取执行结果。

- **解决方法**：需要通过共享变量或线程通信来获取结果，这种方式较为麻烦。

**Callable的优势**：

- **有返回值**：`Callable`接口定义了一个`call()`方法，可以返回一个泛型类型的结果。

- **使用方法**：通常配合`ExecutorService`使用，通过`submit`方法提交任务，并返回一个`Future`对象来获取结果。

- **示例代码**：展示了如何创建一个包含5个线程的线程池，提交`Callable`任务，并通过`Future`对象获取结果。

**Future接口**：

- **功能**：`Future`接口提供了判断任务是否完成、中断任务和获取执行结果的功能。

- **方法**：

- `cancel()`：取消任务。

- `isCancelled()`：判断任务是否被取消。

- `isDone()`：判断任务是否完成。

- `get()`：获取执行结果，可能会阻塞。

- `get(long timeout, TimeUnit unit)`：在指定时间内获取结果，超时返回`null`。

**FutureTask实现类**：

- **实现接口**：`FutureTask`实现了`RunnableFuture`接口，而`RunnableFuture`继承了`Runnable`和`Future`接口，因此`FutureTask`既可以作为`Runnable`被线程执行，又可以作为`Future`获取结果。

- **构造器**：提供了两个构造器用于创建`FutureTask`对象。

## 线程状态

操作系统的线程**三个基本状态**：

![](https://ima-notebook-prod.image.myqcloud.com/2/eeT0U4xKE3xYKKq88fofxe/d6b5c48a114d47e7b2cb556d6fab42cf.webp?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1746605223%3B1746634023&q-key-time=1746605223%3B1746634023&q-header-list=&q-url-param-list=&q-signature=2ff71085d5a64a5db6dc8392308d693de1416c14)

- **就绪状态(ready)**：线程正在等待使用CPU，经调度程序调用之后进入running状态。

- **执行状态(running)**：线程正在使用CPU。

- **等待状态(waiting)**：线程经过等待事件的调用或者正在等待其他资源（如I/O）。

**Java线程的六种状态**

![](https://ima-notebook-prod.image.myqcloud.com/2/eeT0U4xKE3xYKKq88fofxe/2927a804edfb4307b0f5c2f3be0498db.webp?q-sign-algorithm=sha1&q-ak=AKID9IDtLZZKqGRO7hVFnMn0zjXTXovoTtAN&q-sign-time=1746606433%3B1746635233&q-key-time=1746606433%3B1746635233&q-header-list=&q-url-param-list=&q-signature=c6201eb6bd138f89ede5a59730f35e23d611cab8)

- **NEW**：线程尚未启动，未调用Thread实例的start()方法。

- **RUNNABLE**：线程正在运行中，可能正在等待CPU分配资源。包括操作系统线程的ready和running两个状态。

- **BLOCKED**：线程在等待锁的释放。

- **WAITING**：线程处于等待状态，需要其他线程唤醒。通过Object.wait()、Thread.join()、LockSupport.park()等方法进入。

- **TIMED_WAITING**：超时等待状态，线程等待一个具体的时间，时间到后会被自动唤醒。通过Thread.sleep(long)、Object.wait(long)、Thread.join(long)等方法进入。

- **TERMINATED**：线程已执行完毕。

**线程状态的转换**

- **BLOCKED与RUNNABLE状态的转换**：线程在争夺锁时，未抢到锁的线程会进入BLOCKED状态。

- **WAITING状态与RUNNABLE状态的转换**：通过Object.wait()和Thread.join()方法，线程可以从RUNNABLE状态转为WAITING状态。

- **TIMED_WAITING与RUNNABLE状态转换**：通过Thread.sleep(long)、Object.wait(long)、Thread.join(long)方法，线程可以进入TIMED_WAITING状态，时间到后自动唤醒进入RUNNABLE状态。

**线程中断机制**

- **线程中断**：Java提供线程中断机制来处理需要中断线程的情况。中断操作不能直接终止线程，而是通知线程自行处理。

- **Thread类中的中断方法**：Thread类提供了关于线程中断的几个方法，用于设置和检查线程的中断状态。

- **BLOCKED状态示例**：通过两个线程争夺锁来演示BLOCKED状态的产生。

- **WAITING状态示例**：通过Object.wait()和Thread.join()方法演示WAITING状态的转换。

- **TIMED_WAITING状态示例**：通过Thread.sleep(long)和Thread.join(long)方法演示TIMED_WAITING状态的转换。

## 线程组与优先级

**线程组(ThreadGroup)**

- **定义与作用**：Java使用ThreadGroup类来表示线程组，可以对线程进行批量控制。每个Java线程都必须存在于一个线程组中。

- **数据结构**：ThreadGroup是一个树状结构，每个线程组可以包含多个线程或其他线程组。主要成员变量包括父线程组、名称、最大优先级、是否被销毁、是否守护线程等。

- **构造方法**：ThreadGroup有多个构造方法，可以指定父线程组和名称。私有构造方法会调用checkParentAccess方法来检查权限。

**线程优先级**

- **定义与范围**：线程优先级范围是1~10，Java默认优先级为5。优先级高的线程有更高的概率得到执行，但最终调度由操作系统决定。

- **设置与获取**：使用Thread类的setPriority()方法设置优先级，getPriority()方法获取优先级。

- **验证优先级可靠性**：通过创建多个线程并设置不同优先级，验证优先级的可靠性。结果表明，Java中的优先级只是给操作系统的建议，实际调度顺序由操作系统决定。

- **守护线程**：守护线程默认优先级较低，当所有非守护线程结束时，守护线程会自动结束。可以通过Thread类的setDaemon方法设置为守护线程。

**线程组和线程优先级的关系**

- **优先级一致性**：如果某个线程的优先级大于其所在线程组的最大优先级，则该线程的优先级将失效，取而代之的是线程组的最大优先级。

## 线程的安全问题

1. **进程的提出与作用**
    
    - **早期计算机的局限性**：最初的计算机只能接受特定指令，用户输入一个指令，计算机就做出一个操作，效率低下。
    - **批处理操作系统**：将一系列指令写成清单，一次性交给计算机执行，提高了效率，但仍存在串行执行的问题，内存中始终只有一个程序在运行。
    - **进程的提出**：为了解决批处理操作系统的瓶颈，科学家提出了进程的概念。进程是应用程序在内存中分配的空间，各个进程之间互不干扰，CPU采用时间片轮转的方式运行进程，使得宏观上看起来同一时间段可以执行多个任务。
2. **线程的提出与作用**
    
    - **进程的局限性**：虽然进程提高了操作系统的性能，但一个进程在一段时间内只能做一件事情，如果有多个子任务，只能逐个执行，影响效率。
    - **线程的提出**：为了让一个进程中的多个子任务同时执行，提出了线程的概念。一个进程可以包含多个线程，每个线程负责一个单独的子任务。例如，杀毒软件可以同时进行病毒扫描和垃圾清理。
3. **进程与线程的区别**
    
    - **资源管理**：进程单独占有一定的内存地址空间，进程间存在内存隔离，数据共享复杂但同步简单；线程共享所属进程的内存地址空间和资源，数据共享简单但同步复杂。
    - **独立性**：进程是独立的运行环境，一个进程崩溃不会影响其他进程；线程在进程中执行，一个线程崩溃可能影响整个程序的稳定性。
    - **开销**：进程的创建和销毁需要资源的分配和回收，开销较大；线程的创建和销毁只需要保存寄存器和栈信息，开销较小。
    - **系统角色**：进程是操作系统进行资源分配的基本单位，线程是操作系统进行调度的基本单位。
4. **多线程的优势**
    
    - **硬件发展**：随着多核CPU的出现，并发编程变得越来越重要，通过并发编程可以充分利用多核CPU的计算能力。
    - **业务需求**：某些业务场景（如图像处理、网上购物）适合并发编程，多线程技术可以提高应用性能。
5. **操作系统的设计要点**
    
    - **多进程形式**：允许多个任务同时运行。
    - **多线程形式**：允许单个任务分成不同的部分运行。
    - **协调机制**：防止进程之间和线程之间产生冲突，同时允许共享资源。
6. **总结**
    
    - 进程和线程都是操作系统用于并发执行的方式，但它们在资源管理、独立性、开销以及影响范围等方面有所不同。理解这些概念对于编写高效的并发程序至关重要。



# JVM

![[assets/images/JAVA-1.png]]

![[assets/images/JAVA-2.png]]

**重载和重写**

- 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
- 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法

**字符常量和字符串常量**

- 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。
- 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。

**反射（Reflection）**

Java 语言的核心特性之一，允许程序在**运行时**动态地**获取类的信息**（如类名、方法、字段、构造器等），并直接**操作类或对象**的内部属性（包括私有成员）。简单来说，反射让 Java 程序具备了“自省”和“动态行为”的能力。

**成员变量**在运行时可借助反射等方法手动赋值，而**局部变量不行**。

**堆栈、方法区**

| **变量类型**   | **存储位置**    | **生命周期管理** | **示例**                  |
| ---------- | ----------- | ---------- | ----------------------- |
| 局部变量（基本类型） | 虚拟机栈（局部变量表） | 方法结束自动释放   | `int x = 5;`            |
| 非静态成员变量    | 堆（对象实例内部）   | 由GC回收      | `class A { int n; }`    |
| 静态变量（基本类型） | 方法区（元空间）    | 类卸载时释放     | `static int count = 0;` |

**抽象类和接口**

抽象类是对一种事物的抽象，即对类抽象，继承抽象类的子类和抽象类本身是一种 `is-a` 的关系。而接口是对行为的抽象。

抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。

举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类 Airplane，将鸟设计为一个类 Bird，但是不能将飞行这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口 Fly，包含方法 fly()，然后 Airplane 和 Bird 分别根据自己的需要实现 Fly 这个接口。


