# 数组

## 二分查找

```c
// 有序的无重复元素数组

// 写法一：target 在 [left, right] 之间
Class Sloution{
public:
	int search()(vector<int>& nums, int target) {
		int left = 0;
		int right = nums().size - 1;
		while (left <= right) { // left == right 时 target 区间依然成立
			int middle = (left + right) / 2;
			if (nums[middle] > target){
				right = middle - 1;
			} else if (nums[middle] < target) {
				left = middle + 1;
			} else {
				return middle;
			}
		}
		return -1;
	}
};

// 写法二：target 在 [left, right) 之间
Class Sloution{
public:
	int search()(vector<int>& nums, int target) {
		int left = 0;
		int right = nums().size - 1;
		while(left < right){ // 此时左右相等不成立
			int middle = (left + right) / 2;
			if (nums[middle] < target){
				left = middle + 1;
			} else if (nums[middle] > target){
				right = middle;
			} else {
				return middle;
			}
		}
		return -1;
	}		
};
```

## 移除元素

给你一个数组 `nums` 和一个值 `val`，你需要**原地移除**所有数值等于 `val` 的元素，并返回移除后数组的新长度。

```c
// 示例：给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4

// 暴力解法 时间复杂度为 O(n^2)
Class Solution{
public:
	int removeElement(vector<int>& nums, int val){
		int size = nums.size();
		for (int i = 0; i < size; i++){
			if(nums[i] == val){ // 发现需要移除的元素
				// for (int j = i, j < size, j++){
					// nums[j] = nums[j+1]; 导致越界
				for (int j = i+1, j < size, j++){
					 nums[j-1] = nums[j]; 
				}
				i--; // 前移一位
				size--; // 数组减小一位
			}
		}
		return size;
	}
};

// 双指针法：通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作
// 慢指针指向已经处理好的数组 快指针用于遍历数组

Class Solution{
public:
	int removeElement(vactor<int>& nums, int val){
		int slowIndex = 0;
		for (int fastIndex = 0; fastIndex < slowIndex.size(); fastIndex++) {
			if(nums[fastIndex] != val){
				nums[slowIndex++] = nums[fastIndex];
			}
		}
		return slowIndex;
	}
}
```

## 有序数组平方

给你一个按非递减顺序排序的整数数组 nums，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。

```c
// 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]

// 暴力解法 直接平方后快排 O(n+nlogn)
class Solution{
public:
	vector<int> sortedSquares(vector<int>& nums){
		for (int i = 0; i < A.size(); i++){
			A[i] *= A[i];
		}
		sort(A.begin, A.end());
		return A;
	}
};

// 双指针法 O(n)
// 由于正负的存在 原数组有序 最大值一定在数组两端
// 利用左右指针进行平方后数组的排序
class Solution{
public:
	vector<int> sortedSquares(vector<int>& nums){
		int k = A.size() - 1;
		vector<int> result = (A.size, 0);
		for(int i = 0; j = A.size() - 1 ; i <= j;){
			// 大的放尾部
			if(nums[i] * nums[i] > nums[j] * nums[j]){
				result[k--] = nums[i] * nums[i]
				i++;
			} else {
				result[k--] = nums[j] * nums[j]
				j--;
			}
		}
		return result;
	}
}
```

## 长度最小的子数组



