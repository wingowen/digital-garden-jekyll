分布式缓存
- 优点：容量和性能可扩展、高可用。
- 缺点：网络延迟、复杂性。

# 缓存穿透（Cache Penetration）

请求的**数据在数据库和缓存中都不存在**（如恶意请求不存在的 ID）。导致大量无效请求绕过缓存直接访问数据库，导致数据库压力骤增。

**解决方案**

布隆过滤器（Bloom Filter）
- 在缓存层前加布隆过滤器，快速判断数据是否存在。
- 若布隆过滤器标记数据不存在，直接拦截请求，避免查询数据库。

缓存空对象（Cache Null）
- 对数据库查询结果为空的请求，缓存一个短期的空值（如 `key: null, TTL: 5min`），防止重复穿透。

# 缓存击穿（Cache Breakdown）

**某个热点数据过期**时，大量并发请求同时涌入数据库。导致针对单个热点数据的瞬时高并发压力，可能导致数据库崩溃。

**解决方案**

互斥锁（Mutex Lock）
- 当缓存失效时，通过分布式锁（如 Redis 的 `SETNX`）控制只有一个线程重建缓存，其他线程等待并轮询缓存。

逻辑过期（Logical Expiration）
- 缓存不设置物理 TTL，而是在数据中存储逻辑过期时间。
- 后台异步更新数据，避免请求线程阻塞。

永不过期热点数据
- 对极高频的热点数据（如首页 Banner），直接设置为永不过期，通过异步线程定期更新。

# 缓存雪崩（Cache Avalanche）

**大量缓存数据同时过期**，或**缓存服务宕机**。瞬时大规模缓存失效，请求直接冲击数据库，导致系统级联故障。

**解决方案**

随机化过期时间
- 对缓存数据的 TTL 添加随机值（如 `基础时间 + 随机分钟`），避免同时失效。

多级缓存（Multi-level Cache）
- 本地缓存（如 Caffeine） + 分布式缓存（如 Redis），减少对单一缓存层的依赖。

熔断降级与限流
- 通过熔断机制（如 Hystrix）在数据库压力过大时拒绝请求，或限流（如 Sentinel）控制并发量。

集群高可用
- 使用 Redis 集群或哨兵模式，避免单点故障导致全盘崩溃。

# 缓存设计原则

- **缓存空值**：减少无效请求穿透到数据库。
- **分散失效时间**：避免同时失效引发的连锁反应。
- **冗余与降级**：通过多级缓存和熔断机制保障系统可用性。
- **热点隔离**：对高频数据单独处理（如本地缓存 + 永不过期）。

